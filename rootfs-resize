#!/usr/bin/python
import re
import parted
import glob
import os
import ast
import sys
import psutil

abort_blocked = False;

# Check the kernel command line parameter 'nofsresize' was NOT specified
for line in open('/proc/cmdline'):
	if 'nofsresize' in line:
		abort_blocked = True

# Check that /.nofsresize is NOT present
if os.path.isfile('/.nofsresize'):
	abort_blocked = True

# Abort due to either of the above
if abort_blocked:
	sys.exit(1)

for line in open("/proc/self/mountinfo"):
	checkr = re.search("/dev/sdb[1-4]", line)
	if checkr:
		r_major_minor = line.split(' ')[2]
		break
											
rmajor=int(r_major_minor.split(":")[0])
rminor=int(r_major_minor.split(":")[1])

for line in open("/proc/self/mountinfo"):
	checkl = re.search("/dev/sdb[5-9]", line)
	if checkl:
		logical_major_minor = line.split(' ')[2]
		break	
	
lmajor = int(logical_major_minor.split(":")[0])
lminor = int(logical_major_minor.split(":")[1])


root_device = ''
logical_device = ''

for rootdev in glob.glob("/dev/sdb[1-4]*")+glob.glob("/dev/mmcblk*p[1-4]*"):
	rdev=os.stat(rootdev).st_rdev
	if os.major(rdev) == rmajor and os.minor(rdev) == rminor:
		root_device = rootdev
		print root_device # testing purposes
	
		for logdev in glob.glob("/dev/sdb[5-9]*")+glob.glob("/dev/mmcblk*p[5-9]*"):
			ldev=os.stat(logdev).st_rdev
			if os.major(ldev) == lmajor and os.minor(ldev) == lminor:
				logical_device = logdev
				print logical_device # testing purposes
				break
			elif not os.major(ldev) and os.minor(ldev):
				logical_device = ''
				break

disk_device = ''
for pattern in [ '/dev/sdb', '/dev/mmcblk.' ]:
	match = re.match(pattern, root_device)
	if match:
		disk_device = root_device[:match.span()[1]]
		print "Disk device is %s" % disk_device # testing purposes
		break

# Exit if no disk_device is found
if not disk_device:
	sys.exit(2)
	

# PHASE 1
# Resize extended partition to full capacity
def extendedResize():
	#disk_device = '/dev/sdb' # testing purposes
	extended = '/dev/sdb2' # testing purposes
	device = parted.Device(disk_device)
	disk = parted.Disk(device)	
	extended = disk.getPartitionByPath(extended)
	constraint = device.optimalAlignedConstraint
	try:
		new_end = extended.getMaxGeometry(constraint).end
	except TypeError:
		new_end = extended.getMaxGeometry	(constraint.getPedConstraint()).end
	
	disk.setPartitionGeometry(partition = extended, constraint = 	constraint, start = extended.geometry.start, end = new_end)
	try:
		disk.commit()
	except:
		pass

	# change flagfile and reboot
	# open('/.rootfs-resize', 'w').close()
	# os.unlink('/.rootfs-repartition')
	# os.system('/sbin/reboot')

# Resize the logical partition to full capacity
def logicalResize():
	#root_device = '/dev/sdb5'
	#disk_device = '/dev/sdb'
	device = parted.Device(disk_device)
	disk = parted.Disk(device)
	root = disk.getPartitionByPath(root_device)
	constraint = device.optimalAlignedConstraint
	try:
		new_end = root.getMaxGeometry(constraint).end
	except TypeError:
		new_end = root.getMaxGeometry(constraint.getPedConstraint()).end
	
	fs = ('ext2', 'ext3', 'ext4')
	if(root.fileSystem.type in fs) and root.geometry.end < new_end:
	    disk.setPartitionGeometry(partition = root, constraint = constraint, start = root.geometry.start, end = new_end)

	# disk.commit() will usually throw an exception because the kernel is using the rootfs and refuses to accept the new parititon table
	# ... so we reboot
	try:
		disk.commit()
	except:
		pass

	# change flag files and reboot
	# open('/.rootfs-resize', 'w').close()
	# os.unlink('/.rootfs-repartition')
	# os.system('/sbin/reboot')


# PHASE 2
# if /.rootfs-resize exists, resize the filesystem
def fileSystemResize():
	# if os.path.isfile('/.rootfs-resize'):
	# use ionice if available
	root_device = '/dev/sdb5'
	
	if os.path.isfile('/usr/bin/ionice'):
		os.system('/usr/bin/ionice -c2 -n7 /sbin/resize2fs %s' % root_device)
	else:
		os.system('/sbin/resize2fs %s' % root_device)

	
extendedResize()
logicalResize()
fileSystemResize()
